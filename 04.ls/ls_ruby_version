#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'etc'

# 最大列数を定める(今回は3)
MAX_VARIABLE_COLUMNS = 3

# ファイルモードで取得される値のうち権限を示す数字は末尾3桁。
PERMISSION_NUMBER = -3

# カレントディレクトリ配下にあるファイル名を取得
@file_names = Dir.glob('*')

def change_numbers_to_symbols(number)
  numbers_to_symbols = {()
    0 => '---',
    1 => '--x',
    2 => '-w-',
    3 => '-wx',
    4 => 'r--',
    5 => 'r-x',
    6 => 'rw-',
    7 => 'rwx'
  }

  permission_numbers = number.to_s(8)[PERMISSION_NUMBER..]
  permission_symbols = permission_numbers.chars.map(&:to_i)
  permission_symbols.map { |n| numbers_to_symbols[n] }.join
end

def shape_date(file)
  date_string = File::Stat.new(file).ctime.to_s
  match_data = date_string.match(/-\d{2}-\d{2} (\d{2}:\d{2})/)
  match_data[0].tr('-', ' ')
end

def calculate_total_blocks
  file_names = @file_names

  puts "total #{@file_names.sum { |file| File::Stat.new(file).blocks }}"

  file_names.each_with_index do |file, index|
    file_stats = File::Stat.new(file)
    permission_string = change_numbers_to_symbols(file_stats.mode)
    owner_name = Etc.getpwuid(File::Stat.new(file).uid)[0]
    group_name = Etc.getgrgid(File::Stat.new(file).gid)[0]
    file_size = file_stats.size
    formatted_date = shape_date(file)
    file_type = file_stats.ftype[0]
    output_line = "#{file_type}#{permission_string} " \
                  "#{file_stats.nlink.to_s.rjust(file_stats.nlink.to_s.length)} #{owner_name.rjust(owner_name.length)} " \
                  "#{group_name.rjust(group_name.length)} #{file_size.to_s.rjust(file_size.to_s.length)} " \
                  "#{formatted_date.to_s.rjust(formatted_date.to_s.length)} #{file_names[index]}"
    puts output_line
  end
end

def list_directory_contents
  file_names = @file_names

  # 出力時の行数を定める(切り上げ)
  number_of_row = (file_names.size.to_f / MAX_VARIABLE_COLUMNS).ceil

  # 余ってしまう行(余白)に対し要素(nil)を補充し整形に必要な配列を用意
  list_filled_with_blanks = file_names + Array.new(number_of_row * MAX_VARIABLE_COLUMNS - file_names.size, nil)

  # 最大列数にあわせて配列を分割する
  separated_directory_contents = list_filled_with_blanks.each_slice(number_of_row).to_a

  # 最も長いファイル名(文字列)の長さを列幅の基準にする
  max_filename_length = file_names.map(&:length).max

  # 横に展開したときに縦に意図した並び(昇順)が実現できるように配列を変更する。
  separated_directory_contents.transpose.map do |contents_of_row|
    contents_of_row.map { |filename| filename.to_s.ljust(max_filename_length) }.join("\t")
  end
end

def run
  params = ARGV.getopts('l')
  if params['l']
    calculate_total_blocks
  else
    puts list_directory_contents
  end
end

run
